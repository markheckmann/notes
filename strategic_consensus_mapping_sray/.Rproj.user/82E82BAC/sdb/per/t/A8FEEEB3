{
    "contents" : "---\ntitle: \"Strategic consensus mapping (Tarakci et al. 2014) (in progress)\"\nauthor: \"Mark Heckmann\"\ndate: \"13. Dezember 2014\"\noutput: \n  html_document:\n    theme: united\n    toc: yes\n    toc_depth: 3\n---\n\n```{r echo=FALSE}\nknitr::opts_chunk$set(comment=NA, warning=FALSE, message=FALSE)\n```\n\n```{r}\nlibrary(knitr)\nlibrary(plotrix)\n# devtools::install_github('lcolladotor/dots')\nlibrary(dots)\nlibrary(scales)\nlibrary(plyr)\nlibrary(smacof)\n```\n\nIn this script I try to reproduce the *Strategic Consensus Mapping (SCM)* method as outlined by Tarakci et al. (2014) in R. SCM is a combination of four methods or defined measures:\n\n* The vector model of unfolding to visualize respondents preferences\n* A standardized measure of within-group consensus\n* A measure of between-group similarity\n* Multidimensional scaling to visualize between-group similarity\n\n\n# Data\n\n```{r results='markup'}\nx <- read.csv2(\"data/tmt.csv\")\nkable(x)\nH <- x[, -1]\nrownames(H) <- x[, 1]\n```\n\n\n# Vector model of unfolding  \n\nThe vector model of unfolding is used to geometrically visualize each respondents preference order of the strategic items.\n\n```{r}\n#http://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d/897677#897677\nmatrix_to_rotate_x_on_y <- function(x,y) \n{\n  x <- x / sum(x^2)^.5\n  y <- y / sum(y^2)^.5\n  matrix(c(x[1]*y[1] + x[2]*y[2], x[1]*y[2] - x[2]*y[1],\n         -(x[1]*y[2] - x[2]*y[1]), x[1]*y[1] + x[2]*y[2]), 2, by=T)\n}\n\n\nvmu <- function(H, reflect=c(F,F))\n{\n  n <- nrow(H)                  # n x m matrix\n  m <- nrow(H)\n  H <- scale(H) * (n/(n-1))^.5  # scale with n not n-1\n  dec <- svd(H)\n  U <- dec$u\n  V <- dec$v\n  r <- length(dec$d)  \n  D <- diag(dec$d, r, r)\n  R <- diag( ifelse(reflect == 0, 1, -1) )\n\n  l <- m^.5               # lambda scaling of decompsoition\n  X <- l * U              # no singular values assigned to row points\n  A <- l^-1 * V %*% D     # makes each squared rowsums equal to one\n  X <- X[, 1:2] %*% R     # get first two principal components and \n  A <- A[, 1:2] %*% R     # flip axes if prompted\n  \n  rownames(X) <- rownames(H) \n  rownames(A) <- colnames(H)\n  \n  am <- colMeans(A)           # average loading vector\n  alpha <- (sum(am^2))^.5     # calculate alpha measure using unrotated \n                              # solution, p. 1059\n  \n  Q <- matrix_to_rotate_x_on_y(am, c(1,0))  # rotate plot so am corresponds\n  XQ <- X %*% Q                             # with x-axis\n  AQ <- A %*% Q \n\n  list(H=H,           # original input (high preference = low value)\n       X=X,           # matrix of row points\n       A=A,           # matrix of column vectors\n       XQ=XQ,         # matrix of row points after rotation on average column vector\n       AQ=AQ,         # matrix of column vectors after rotation\n       a=am,          # average column vector\n       alpha=alpha)   # measure of within-group consensus             \n}\n\n\n# function for textboxes (uses dots and plotrix package)\ntextbox2_ <- function(x,y, label, ...)\n{\n  w <- dots::formal_call(\"strwidth\", s=label, ...) / 2 * 1.1\n  plotrix::textbox(c(x - w, x + w), y, label, justify=\"c\", ...)\n  #formal_call(\"textbox\", x=c(x - w, x + w), y=y, \n  #          textlist=label, justify=\"c\", ...)\n}\ntextbox2 <- Vectorize(textbox2_)\n\n\nplot_vmu <- function(v, prop=.9, rows=TRUE, columns=TRUE, \n                     average=TRUE, circle=TRUE, frame=FALSE) \n{\n  X <- v$XQ\n  A <- v$AQ\n  \n  # rescale X to fit within unit circle. This destroys projection property but \n  # not important as no axis calibration is used in plot\n  X <- X / max(rowSums(X^2)^.5)         # scale X to fit within unit circle\n  X <- X * prop                         # make a bit smaller than uni circle   \n  \n  # set up plot\n  mx <- 1.1 #max(max(abs(X)), max(abs(A)))   # max value to set plot limits\n  op <- par(mar=c(.5,.5,.5,.5))\n  plot(NULL, xlim=c(-mx, mx), ylim=c(-mx, mx), asp=1, \n       xaxt=\"n\", yaxt=\"n\", xaxs=\"i\", yaxs=\"i\", xlab=\"\", ylab=\"\",\n       frame=frame)\n  if (circle) {\n    draw.circle(0,0,1, col = grey(.97))\n  }\n  segments(-1, 0, 1, 0, col=\"grey\")\n  segments(0, -1, 0, 1, col=\"grey\")\n    \n  # respondents (variables)\n  if (columns) {\n    segments(0,0,A[,1],A[,2], col=\"blue\", lwd=2)\n    points(A, col=\"#0000FF90\", pch=15)\n    pos <- ifelse(A[,1] > 0, 4, 2)   # position labels by hemisphere\n    text(A, labels=rownames(A),cex=.7, pos=pos, col=\"blue\")    \n  }\n\n  # row objects\n  if (rows) {\n    points(X, pch=18, col=\"#FF000090\", cex=1.5)\n    text(X, labels=rownames(X), col=\"red\", cex=.7, pos=3) \n    #textbox2(X[, 1], X[, 2], label=rownames(X), \n    #         col=\"red\", cex=.7)\n  }\n  \n  # average of all vectors ( ~ prototypical respondent)\n  am <- colMeans(A[, 1:2])  \n  if (average) {\n    #segments(0,0, am[1], am[2], lwd=2) \n    arrows(0,0,am[1], am[2], lwd=2, length = .1)\n  }\n  \n  # the squared row sums of A are one, so 1 is maximal length of average \n  par(op)\n}\n```\n\nThe following graphic is a reproduction of Figure 1 (p. 1058). The scaling of the objects might differ to the one in the paper. This will hoewever not affect interpretation of the solution, as the respondents axis are not calibrated using tick marks. Also, we chose to draw a unit circle, to indicate the longest possible vector.\n\n```{r}\nv <- vmu(H)\nplot_vmu(v)\n```\n\nTo read off the approximated preference order of each strategic items for a respondent, the items are orthogonally projected on the respondent's axis. \n\n```{r}\nadd_axes <- function(A, col=\"#0000FF50\", lwd=2, lty=5)\n{\n  if (!is.matrix(A))            # convert if a vector\n    A <- matrix(A, ncol=2, by=T)     \n  A <- t(apply(A, 1, function(x) x / sum(x^2)^.5 ))\n  segments(-A[ ,1], -A[ ,2], 0, 0, lty=lty, col=col, lwd=lwd)\n}\n\n\nadd_projections <- function(v, i=NULL, j=NULL)\n{\n  X <- v$XQ\n  A <- v$AQ\n  if (is.null(i)) \n    i <- 1L:nrow(X)    \n  if (is.null(j))\n    j <- 1L:nrow(A)\n  \n  X <- X / max(rowSums(X^2)^.5) * .9   # scale X to fit within unit circle\n\n  # draw respondent axes\n  add_axes(A[j, ], col=\"#0000FF50\")\n\n  # draw projections of row points on respondent axes\n  Xs <- X[i, , drop=FALSE]   # select points to project\n  for (jj in j) {\n    a <- A[jj, ]                              # current axis to project on\n    P <- a %*% t(a) / as.numeric(t(a) %*% a)  # projection matrix\n    Ps <- Xs %*% P                            # project all points\n    segments(Xs[,1], Xs[,2], Ps[,1], Ps[,2], lty=2)    \n  }\n}\n```\n\n```{r}\nplot_vmu(v)\nadd_projections(v, j=1)\n```\n\n```{r}\n# preference orders reproduced by projected order\npreferences <- function(v, j=NULL)\n{\n  H <- v$H\n  R <- v$H\n  R[ , ] <- NA\n  X <- v$XQ\n  A <- v$AQ\n  if (is.null(j))\n    j <- 1L:nrow(A)\n  for (jj in 1L:nrow(A)) {\n    a <- v$AQ[jj, ]                           # current axis to project on\n    P <- a %*% t(a) / as.numeric(t(a) %*% a)  # projection matrix for axis j\n    Xp <- X %*% P                             # projections (not scaled like plot)\n    d <- svd(Xp)                              # projection coords in PCA space\n    pc1 <- d$u[, 1] * d$d[1]                  # coords on first PC in PCA system\n    \n    v1 <- d$v[, 1]          # 1st right singular vector, i.e. direction of PC1\n    an <- a / sum(a^2)^.5   # a to length 1\n    if (t(v1) %*% an < 0)   # Reflect coords if PC does not match \n      pc1 <- pc1 * -1       # direction of respondent vector  \n\n    R[ , jj] <- rank(pc1)   # order(order(pc1))    # to avoid bindings\n  }\n  rownames(R) <- rownames(H)\n  R[ , j, drop=FALSE]\n}\n```\n\nThe reproduced preference order for respondent 7 is slightly different from the original one. The following table compares the two orders and shows the absolute differences for the rank. \n\n```{r}\nj <- 7\npref <- preferences(v, j=j) \npp <- cbind(H[, j], pref, abs(H[, j] - pref))\ncolnames(pp) <- c(\"original\", \"reproduced\", \"delta\")\npp\n```\n\nSome preference orders are better reproduced than others. The following table shows the deltas in rank order for all respondents. The order for respondent 1 is reproduced perfectly in the plot while the reproduction for the order of respÃ¼ondent 8 is the worst. This could also be expected from inspecting the length of respondent8's vector, as it is shorter than the others.\n\n```{r}\nabs(H - preferences(v)) \n```\n\n\n# A measure of consensus for each group \n\nThe authors suggest a measure of within-group consensus. It builds upon the length of the vector of the average repondent. It is defined as\n\n$$\n\\alpha = \\sqrt{ \\sum_{p=1}^2 \\Big( n^{-1} \\sum_i a_{ip} \\Big)^2}\n$$\n\n(p. 1059) with $\\alpha \\in [0,1]$. FOOTNOTE: Note that the formula for $\\alpha$ in Tarakci et al. (2014) has an error, as it uses $m^{-1}$ instead of $n^{-1}$ to caclulate the average, although $\\mathbf{A}$ has $n$ rows.\n\nAs the vectors for all respondents have a maximum length of one (i.e. when they touch the unit circle) also the average respondent vector has a maximal length of one. This is the case when all respondent's vectors point into the same direction. It will be near to zero, if all respondents vectors point into different directions. For our example the value is `r round(v$alpha, 2)`.\n\n\n# A measure of between-group similarity\n\nBesides an inter-group consensus measure the authors supply a measure to compare the similarity of the preference judgements across groups. They suggest to use the scores of the strategy items on the first principal compenent of te rotated solution. The direction of the PC is the same as the direction of the protoypical group member. In other words, the PC values reflect the order of the items for the prototypical group member.\n\n```{r fig.width=8, fig.height=8}\n# create random data\nrandom_preferences <- function()\n{\n  \n}\n\nset.seed(0)\nrnames <- rownames(H)\nl <- replicate(9, apply(H, 2, sample), simplify = FALSE)  # permute data\nl <- lapply(l, function(x) {  \n  x <- x[, 1:sample(5:9, 1)]    # change size\n  rownames(x) <- rnames         # add rownames\n  x\n})         \nvmus <- lapply(l, vmu)\nop <- par(mfrow=c(3,3))\ndummy <- lapply(vmus, plot_vmu)\npar(op)\n```\n\n```{r}\nvv <- c(list(v), vmus)                        # add first VMU result to list\n\nproximities <- function(l)\n{\n  d <- plyr::ldply(vv, function(x) x$XQ[, 1])   # matrix of PC1 coords\n  S <- cor(t(d))                                # similarity matrix\n  D <- 1 - S                                    # dissimilarity matrix  \n  list(S=S, D=D)\n}\n# overall measure of inter-group similarity \nr_overall <- function(S)\n{\n  rs <- S[upper.tri(S)]\n  sqrt(mean(rs^2))\n}\n\np <- proximities(vv)\n```\n\nFor our random data the overall measure for inter-group similarity is `r round(r_overall(p$S), 2)`.\n\n\n# Multidimensional scaling to visualize between-group similarity\n\nThe last step is to visualize the preference similarities between groups. Herefore the authors apply MDS to the dissimilarity matrix.\n\n```{r}\nres <- smacof::smacofSym(p$D, ndim=2, type=\"interval\")\nC <- res$conf\nplot(C)\n```\n\n```{r}\n# between group similariry correlation matrix (Appendix p.1069).\ndeps <- c(\"TMT\", \"Strategy\", \"HR\", \"Sales\", \"Operations\", \n          \"Finance\", \"IT\", \"Business Development\", \"Communication\", \"Safety\")\n\ntri <- c(\n1.00,\n0.72, 1.00,\n0.71, 0.78, 1.00,\n0.86, 0.96, 0.81, 1.00,\n0.41, 0.74, 0.84, 0.62, 1.00,\n0.74, 0.82, 0.88, 0.80, 0.82, 1.00,\n0.79, 0.91, 0.95, 0.94, 0.76, 0.85, 1.00,\n-0.03, 0.33, 0.58, 0.27, 0.60, 0.30, 0.46, 1.00,\n0.77, 0.88, 0.95, 0.87, 0.87, 0.96, 0.94, 0.40, 1.00,\n0.86, 0.71, 0.87, 0.78, 0.72, 0.90, 0.81, 0.31, 0.91, 1.00)\n\nn <- length(deps)\nU <- matrix(NA, n, n)\nU[upper.tri(U, diag = T)] <- tri\nR <- t(U)\nR[upper.tri(R)] <- U[upper.tri(U)]\nD <- 1 - R\ncolnames(D) <- deps\nrownames(D) <- deps\n```\n\n```{r}\nres <- smacof::smacofSym(D, ndim=2, type=\"interval\")\nC <- res$conf\nplot(C, asp=1)\ntext(C, labels=deps)\n\n# isocontour lines\ng <- 1\n# calc euclidean distances to group\nxy <- C[g, ]\nG <- sweep(C, 2, xy, \"-\")\ne <- rowSums(G^2)^.5   # euclidean distances to points from point g\nrs <- p$D[ , 1]        # 1 - rs\nd <- data.frame(r=rs[-g], e=e[-g])\nm <- lm(e ~ r, data=d)\nm$residuals\n# group to center\n\n```\n\n# Literature\n\n* Tarakci, M., Ates, N. Y., Porck, J. P., van Knippenberg, D., Groenen, P. J. F., & de Haas, M. (2014). Strategic consensus mapping: A new method for testing and visualizing strategic consensus within and between teams. Strategic Management Journal, 35(7), 1053â1069. doi:10.1002/smj.2151\n\n\n# TODO\n\nthe component loadings in A are the correlations between the object scores for each strategy item and the respondentsâ answers.\n\n```{r eval=FALSE}\nlibrary(pmr)\n#cor(H[, 1], X[1, ])\n# rotation \n\n## create an artificial dataset\nX1 <- c(1,1,2,2,3,3)\nX2 <- c(2,3,1,3,1,2)\nX3 <- c(3,2,3,1,2,1)\nX4 <- c(1,1,3,3,2,2)\nn <- c(6,5,4,3,2,1)\ntest <- data.frame(X1,X2,X3,X4, n)\n \n## multidimensional preference analysis of the artificial dataset\nd <- mdpref(test,rank.vector=F, 2)\nabline(v=0, h=0, col=\"grey\")\nA <- d$ranking[, 6:7]\nsegments(0,0, A[,1], A[,2])\n```\n\n",
    "created" : 1438997558635.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2770590210",
    "id" : "A8FEEEB3",
    "lastKnownWriteTime" : 1438998004,
    "path" : "~/Dropbox/_mh/uni/writings/mds/strategic_consensus_mapping_sray/strategic_consensus_mapping_sray.Rmd",
    "project_path" : "strategic_consensus_mapping_sray.Rmd",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}